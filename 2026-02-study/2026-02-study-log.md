# 🗓️ 2026-01-28 (수)
**1. 작은 프로젝트에도 MVC가 꼭 필요할까?**
- 자바 명언 게시판을 구현하면서, **요구사항이 비교적 간단하고 단순한 경우에도 MVC 패턴을 사용하는 게 오버엔지니어링이 아닐지** 우려되었다. 
- 하지만 초반부터 MVC 패턴으로 설계하는 것이 기능을 클래스별로 분리해서 넣기에도 편하고, 이후에 기능이 확장될 때 유지보수하기 용이하다는 점을 느꼈다. 

<br>
<br>

# 🗓️ 2026-01-29 (목)
### 🧩 언제 static을 사용할까?
static은 멤버 변수나 메서드를 클래스에 종속시킬 때 사용한다.  

**상태 없는 유틸성 클래스**인 경우 static을 사용하는 게 더 자연스럽다.  
(_상태를 가지지 않는다: 객체 내부에서 값을 저장하지 않고, 단순히 값을 입력받고 처리해서 반환하는 기능만을 수행한다_)

MVC 구조에서 View는 흔히 static 기반의 유틸리티 클래스로 남겨두지만 그 외(Controller 등)에선 static을 지양하고 인스턴스(객체)로 사용하는 것이 권장된다. 

**static을 지양해야 하는 이유: '확장성'과 '테스트 독립성'**  
**static이 불리한 경우: 상태를 내부 필드에 저장해야 할 때, 객체마다 다른 상태/데이터를 가져야 할 때**

### 🧩 Scanner의 위치
`Scanner scanner = new Scanner(System.in)`  

`System.in`(시스템 자원)과 이를 가져오는 `Scanner` 객체는 전체 프로그램 내에서 하나만 생성해 공유하는 것이 메모리 관리와 테스트 측면(자동화 테스트(입력값 미리 넣어두기))에서 유리하다. 

- Application: Scanner 생성 → Controller 생성자 호출 시 전달
- Controller: 전달받은 Scanner를 자기 필드에 보관
- Controller → View: 입력이 필요할 때 InputView.read(scanner) 식으로 빌려줌. 

<br>
<br>

# 🗓️ 2026-01-30 (금)
## 🧩 프로그래머스 코테 문법 정리
#### 1. 배열 관련
&rightarrow; [자바 배열 문법 정리](https://velog.io/@hjy648012/%EC%BD%94%ED%85%8C-%EC%9E%90%EB%B0%94-%EB%B0%B0%EC%97%B4-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC)  
- 특히 `Arrays.sort()`는 최댓값, 최솟값을 찾거나 순서를 세울 때 유용하게 쓸 수 있다.  
- 예) 최댓값 두 개 곱하기, 삼각형 조건 (변 길이 비교)

#### 2. 향상된 for문
- 인덱스(i) 없이 요소만 순차적으로 꺼낼 때 사용한다.  
- 사용 가능 대상: 배열, 리스트, 셋 등 Iterable 인터페이스를 구현한 클래스에선 모두 사용 가능하다.  
- 단, String과 Map은 직접 사용할 수 없어 변환 과정이 필요하다. 

#### 3. 삼항 연산자
- 문법: `(조건식) ? 참일_때_값 : 거짓일_때_값;`
- 용도: 단순한 if-else 문을 리턴해야 할 때 코드를 간결하게 만들어 준다.

#### 4. 메서드 체이닝 기법과 자바 Stream
- 메서드가 '객체 자신'을 반환한 다음 점(.)을 찍고 이어서 다음 할 일을 시키는 **기법**이다.   
    ```java
    // 단순히 문자를 뒤집는 '과정'을 체이닝으로 표현
    String result = new StringBuilder("abc").reverse().append("d").toString();
    ```
- 자바의 Stream 문법은 메서드 체이닝 기법을 활용하여, 데이터를 '흐름'에 따라 설계할 때 사용하는 **도구**이다.  
    ```java
    // 여러 데이터 중 '조건에 맞는 것만 골라내는 과정'을 체이닝으로 표현
    long count = Arrays.stream(numbers) // 1. 스트림 생성
                    .filter(n -> n > 10) // 2. 가공 (체이닝)
                    .count();            // 3. 결과 (체이닝)
    ```

#### 5. 가변 문자열 클래스 (StringBuilder & StringBuffer)
- String은 '불변'이라 수정 시 매번 새로운 객체를 생성(참조값 교체)해야 하지만, 위 클래스들은 내장된 메모리 공간(버퍼)을 활용해 하나의 객체 안에서 데이터를 직접 수정한다. 
- **StringBuilder**: 단일 스레드 환경(일반적인 상황)에서 가장 빨라 주로 사용된다. 
- **StringBuffer**: 멀티스레드 환경에서 데이터 안전성(동기화)을 보장한다. 
- 핵심 메서드: `.append()`, `.reverse()`, `.insert()`, `.delete()`, `.toString()`

<br>
<br>